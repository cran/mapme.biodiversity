<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Terminology</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>







<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Terminology</h1>



<p>Here we present a quick introduction to the most important
terminologies and concepts used throughout this tutorial:</p>
<ul>
<li><p><strong>Portfolio</strong>: We define a portfolio as the
collection of single assets in an <code>{sf}</code> object. The package
does only allow assets with geometries of type <code>&#39;POLYGON&#39;</code> or
<code>&#39;MULTIPOLYGON&#39;</code> to be included in the object. We expect the
data to be in geodetic, i.e. unprojected, coordinates. In case the CRS
of the portfolio is projected, we will attempt to transform to
<code>EPSG:4326</code>. Any metadata that is needed for your analysis is
allowed in the columns of the object and will be retained throughout the
workflow so that you can access it once you have calculated your
indicators. The package will add a <em>nested list columns</em> for each
indicator to the portfolio <code>sf</code>-object. Portfolio-wide
arguments that govern the processing workflow, are set using the
<code>mapme_options()</code> config functions.</p></li>
<li><p><strong>Resources</strong>: A resource is a supported dataset
that can be downloaded via the <code>get_resources()</code> function. A
resource represents either a raster or a vector data set. Vector
datasets are saved to disk as GeoPackages. Raster datasets can be tiled
so that only tiles that cover the spatial extent of the portfolio will
be downloaded. Global raster resources will be downloaded completely.
Additionally, some raster resources are time-invariant (e.g. a
<code>nasa_srtm</code>), others contain a temporal dimension
(e.g. <code>esalandcover</code>). If a raster resource contains a
temporal dimension, only those rasters intersecting with user supplied
time-frame will be downloaded. To learn about resources and their
arguments simply query the help-page for that resource (e.g. via
<code>?gfw_treecover</code>).</p></li>
<li><p><strong>Indicators</strong>: An indicator calculates a tabular
output for all assets in a portfolio. Every indicator requires one or
more resources to be available locally and will inform you about any
missing resources. Custom arguments might be set for some indicators,
but sensible defaults have been set. The package will inform you about
any misspecification of arguments. To learn more about a specific
indicator and its required arguments, simply query the help-page
(e.g. via <code>?treecover_area</code>). The output for indicators is
standardized and is represented by a tibble with columns
<code>datetime</code>, <code>variable</code>, <code>unit</code>, and
<code>value</code>. Indicators are appended to the portfolio as
<em>nested list columns</em>. For assets where no sensible values can be
calculated (e.g. for polygons over the ocean and the
<code>treecover_area</code> indicator), <code>NULL</code> will be
returned.</p></li>
<li><p><strong>Engines</strong>: Several indicators support different
engines for the extraction of the numeric outputs. Currently, these
engines are based on either <code>terra::zonal()</code>,
<code>terra::extract()</code>, or
<code>exactextractr::exact_extract()</code>. We took great care to set
these engines to sensible defaults. However, to customize your workflow
you can choose to use a different engine instead.</p></li>
<li><p><strong>Processing Modes</strong>: The processing mode is an
important concept if you wish to extend the package with a new
indicator, but not so much if you simply want to use it for your
statistical analysis. For most indicators the default processing mode is
equal to <code>&#39;asset&#39;</code>, meaning that for each asset in the
portfolio the required input resources are matched to the
spatio-temporal extent of that specific asset and then the indicator
calculation is conducted. For some resources/indicators this is not the
most efficient approach. These are most commonly very coarse resolution
raster resources where a cropping of many relatively small assets would
lead to an increased overhead and as a result very long processing
times. For these indicators, the default processing mode is set to
<code>&#39;portfolio&#39;</code>, meaning that the indicator is first calculated
for the complete spatio-temporal extent of the portfolio and then the
extraction is conducted for every single asset. If you want to open a
pull-request for a new indicator for which neither of these two
approaches yields satisfactory performance, please contact the package
maintainers to discuss your use-case in order to evaluate if another
processing mode can be added.</p></li>
</ul>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
